{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap d97e102e77d713101846","webpack:///./~/browser-headers/lib/index.js","webpack:///./lib/index.js","webpack:///./lib/defaultChunkParser.js","webpack:///./lib/defaultTransportFactory.js","webpack:///./lib/impl/fetch.js","webpack:///./lib/impl/mozXhr.js","webpack:///./lib/impl/xhr.js","webpack:///./lib/util.js","webpack:///./~/browser-headers/lib/BrowserHeaders.js","webpack:///./~/browser-headers/lib/js/iterateHeaders.js","webpack:///./~/browser-headers/lib/util.js","webpack:///./lib/entry.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,iC;;;;;;;ACJA;;AAEA;AACA;AACA,CAAC;;AAED,kCAAkC,iCAAiC,eAAe,eAAe,gBAAgB,oBAAoB,MAAM,0CAA0C,+BAA+B,aAAa,qBAAqB,mCAAmC,EAAE,EAAE,cAAc,WAAW,UAAU,EAAE,UAAU,MAAM,yCAAyC,EAAE,UAAU,kBAAkB,EAAE,EAAE,aAAa,EAAE,2BAA2B,0BAA0B,YAAY,EAAE,2CAA2C,8BAA8B,EAAE,OAAO,6EAA6E,EAAE,GAAG,EAAE;;AAErpB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wEAAwE;AACxE;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;AC1HA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA,KAAK,iCAAiC;AACtC,KAAK;AACL;AACA;AACA;AACA;AACA,sEAAsE;AACtE;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,C;;;;;;;AChDA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,YAAY;AACf;AACA,C;;;;;;;ACjDA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA,sBAAsB,yEAAyE;AAC/F;AACA;AACA,GAAG;AACH,C;;;;;;;ACpDA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACrDA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAoD,eAAe;AACnE;;AAEA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;AC5DA;;AAEA;AACA;AACA,CAAC;;AAED,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;AChBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,iCAAiC,YAAY,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,gC;;;;;;ACzEA","file":"chunked-request.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"chunkedRequest\"] = factory();\n\telse\n\t\troot[\"chunkedRequest\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d97e102e77d713101846","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BrowserHeaders_1 = require(\"./BrowserHeaders\");\nexports.default = BrowserHeaders_1.default;\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browser-headers/lib/index.js\n// module id = 0\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.default = chunkedRequest;\n\nvar _util = require('./util');\n\nvar _defaultTransportFactory = require('./defaultTransportFactory');\n\nvar _defaultTransportFactory2 = _interopRequireDefault(_defaultTransportFactory);\n\nvar _defaultChunkParser = require('./defaultChunkParser');\n\nvar _defaultChunkParser2 = _interopRequireDefault(_defaultChunkParser);\n\nvar _browserHeaders = require('browser-headers');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// chunkedRequest will make a network request to the URL specified in `options.url`\n// passing chunks of data extracted by the optional `options.chunkParser` to the\n// optional `options.onChunk` callback. When the headers of the response are received\n// the optional `options.onHeaders` callback will be invoked with the headers as an\n// instance of BrowserHeaders and the numeric status code. When the request has\n// completed the optional `options.onComplete` callback will be invoked.\nfunction chunkedRequest(options) {\n  validateOptions(options);\n\n  var url = options.url;\n  var headers = options.headers;\n  var _options$method = options.method;\n  var method = _options$method === undefined ? 'GET' : _options$method;\n  var body = options.body;\n  var _options$credentials = options.credentials;\n  var credentials = _options$credentials === undefined ? 'same-origin' : _options$credentials;\n  var _options$onHeaders = options.onHeaders;\n  var onHeaders = _options$onHeaders === undefined ? _util.noop : _options$onHeaders;\n  var _options$onComplete = options.onComplete;\n  var onComplete = _options$onComplete === undefined ? _util.noop : _options$onComplete;\n  var _options$onChunk = options.onChunk;\n  var onChunk = _options$onChunk === undefined ? _util.noop : _options$onChunk;\n  var _options$chunkParser = options.chunkParser;\n  var chunkParser = _options$chunkParser === undefined ? _defaultChunkParser2.default : _options$chunkParser;\n\n  // parserState can be utilised by the chunkParser to hold on to state; the\n  // defaultChunkParser uses it to keep track of any trailing text the last\n  // delimiter in the chunk.  There is no contract for parserState.\n\n  var parserState = void 0;\n\n  function processRawHeaders(headers, status) {\n    onHeaders(headers, status);\n  }\n\n  function processRawChunk(chunkBytes) {\n    var flush = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n    var parsedChunks = null;\n    var parseError = null;\n\n    try {\n      var _chunkParser = chunkParser(chunkBytes, parserState, flush);\n\n      var _chunkParser2 = _slicedToArray(_chunkParser, 2);\n\n      parsedChunks = _chunkParser2[0];\n      parserState = _chunkParser2[1];\n    } catch (e) {\n      parseError = e;\n      parseError.chunkBytes = chunkBytes;\n      parseError.parserState = parserState;\n    } finally {\n      if (parseError || parsedChunks && parsedChunks.length > 0) {\n        onChunk(parseError, parsedChunks);\n      }\n    }\n  }\n\n  function processRawComplete(rawComplete) {\n    if (parserState) {\n      // Flush the parser to process any remaining state.\n      processRawChunk(new Uint8Array(0), true);\n    }\n    onComplete(rawComplete);\n  }\n\n  var transport = options.transport;\n  if (!transport) {\n    transport = chunkedRequest.transportFactory();\n  }\n\n  transport({\n    url: url,\n    headers: new _browserHeaders.BrowserHeaders(headers || {}),\n    method: method,\n    body: body,\n    credentials: credentials,\n    onRawHeaders: processRawHeaders,\n    onRawChunk: processRawChunk,\n    onRawComplete: processRawComplete\n  });\n}\n\n// override this function to delegate to an alternative transport function selection\n// strategy; useful when testing.\nchunkedRequest.transportFactory = _defaultTransportFactory2.default;\n\nfunction validateOptions(o) {\n  // Required.\n  if (!(0, _util.isObject)(o)) throw new Error('Invalid options argument');\n  if (typeof o.url !== 'string' || o.length === 0) throw new Error('Invalid options.url value');\n\n  // Optional.\n  if (o.onComplete && typeof o.onComplete !== 'function') throw new Error('Invalid options.onComplete value');\n  if (o.onHeaders && typeof o.onHeaders !== 'function') throw new Error('Invalid options.onHeaders value');\n  if (o.onChunk && typeof o.onChunk !== 'function') throw new Error('Invalid options.onChunk value');\n  if (o.chunkParser && typeof o.chunkParser !== 'function') throw new Error('Invalid options.chunkParser value');\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/index.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = defaultChunkParser;\nvar entryDelimiter = '\\n';\n\n// The defaultChunkParser expects the response from the server to consist of new-line\n// delimited JSON, eg:\n//\n//  { \"chunk\": \"#1\", \"data\": \"Hello\" }\\n\n//  { \"chunk\": \"#2\", \"data\": \"World\" }\n//\n// It will correctly handle the case where a chunk is emitted by the server across\n// delimiter boundaries.\nfunction defaultChunkParser(bytes) {\n  var state = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n  var flush = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n  if (!state.textDecoder) {\n    state.textDecoder = new TextDecoder();\n  }\n  var textDecoder = state.textDecoder;\n  var chunkStr = textDecoder.decode(bytes, { stream: !flush });\n  var jsonLiterals = chunkStr.split(entryDelimiter);\n  if (state.trailer) {\n    jsonLiterals[0] = '' + state.trailer + jsonLiterals[0];\n    state.trailer = '';\n  }\n\n  // Is this a complete message?  If not; push the trailing (incomplete) string \n  // into the state. \n  if (!flush && !hasSuffix(chunkStr, entryDelimiter)) {\n    state.trailer = jsonLiterals.pop();\n  }\n\n  var jsonObjects = jsonLiterals.filter(function (v) {\n    return v.trim() !== '';\n  }).map(function (v) {\n    return JSON.parse(v);\n  });\n\n  return [jsonObjects, state];\n}\n\nfunction hasSuffix(s, suffix) {\n  return s.substr(s.length - suffix.length) === suffix;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/defaultChunkParser.js\n// module id = 2\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = defaultTransportFactory;\n\nvar _fetch = require('./impl/fetch');\n\nvar _fetch2 = _interopRequireDefault(_fetch);\n\nvar _mozXhr = require('./impl/mozXhr');\n\nvar _mozXhr2 = _interopRequireDefault(_mozXhr);\n\nvar _xhr = require('./impl/xhr');\n\nvar _xhr2 = _interopRequireDefault(_xhr);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar selected = null;\n\nfunction defaultTransportFactory() {\n  if (!selected) {\n    selected = detectTransport();\n  }\n  return selected;\n}\n\nfunction detectTransport() {\n  if (typeof Response !== 'undefined' && Response.prototype.hasOwnProperty(\"body\") && typeof Headers === 'function') {\n    return _fetch2.default;\n  }\n  var mozChunked = 'moz-chunked-arraybuffer';\n  if (supportsXhrResponseType(mozChunked)) {\n    return _mozXhr2.default;\n  }\n\n  return _xhr2.default;\n}\n\nfunction supportsXhrResponseType(type) {\n  try {\n    var tmpXhr = new XMLHttpRequest();\n    tmpXhr.responseType = type;\n    return tmpXhr.responseType === type;\n  } catch (e) {/* IE throws on setting responseType to an unsupported value */}\n  return false;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/defaultTransportFactory.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.READABLE_BYTE_STREAM = undefined;\nexports.default = fetchRequest;\n\nvar _browserHeaders = require('browser-headers');\n\nvar READABLE_BYTE_STREAM = exports.READABLE_BYTE_STREAM = 'readable-byte-stream';\n\nfunction fetchRequest(options) {\n  var onRawChunk = options.onRawChunk;\n  var onRawComplete = options.onRawComplete;\n  var method = options.method;\n  var body = options.body;\n  var credentials = options.credentials;\n\n  var headers = options.headers.toHeaders();\n\n  function pump(reader, res) {\n    return reader.read().then(function (result) {\n      if (result.done) {\n        setTimeout(function () {\n          onRawComplete({\n            statusCode: res.status,\n            transport: READABLE_BYTE_STREAM,\n            raw: res\n          });\n        });\n        return;\n      }\n      onRawChunk(result.value);\n      return pump(reader, res);\n    });\n  }\n\n  function onError(err) {\n    setTimeout(function () {\n      options.onRawComplete({\n        statusCode: 0,\n        transport: READABLE_BYTE_STREAM,\n        raw: err\n      });\n    });\n  }\n\n  fetch(options.url, { headers: headers, method: method, body: body, credentials: credentials }).then(function (res) {\n    options.onRawHeaders(new _browserHeaders.BrowserHeaders(res.headers), res.status);\n    return pump(res.body.getReader(), res);\n  }).catch(onError);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/impl/fetch.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MOZ_CHUNKED = undefined;\nexports.default = mozXhrRequest;\n\nvar _browserHeaders = require('browser-headers');\n\nvar MOZ_CHUNKED = exports.MOZ_CHUNKED = 'moz-chunked';\n\nfunction mozXhrRequest(options) {\n  var xhr = new XMLHttpRequest();\n\n  function onProgressEvent() {\n    options.onRawChunk(new Uint8Array(xhr.response));\n  }\n\n  function onLoadEvent() {\n    options.onRawComplete({\n      statusCode: xhr.status,\n      transport: MOZ_CHUNKED,\n      raw: xhr\n    });\n  }\n\n  function onStateChange() {\n    if (this.readyState == this.HEADERS_RECEIVED) {\n      options.onRawHeaders(new _browserHeaders.BrowserHeaders(this.getAllResponseHeaders()), this.status);\n    }\n  }\n  function onError(err) {\n    options.onRawComplete({\n      statusCode: 0,\n      transport: MOZ_CHUNKED,\n      raw: err\n    });\n  }\n\n  xhr.open(options.method, options.url);\n  xhr.responseType = 'moz-chunked-arraybuffer';\n  options.headers.forEach(function (key, values) {\n    xhr.setRequestHeader(key, values.join(\", \"));\n  });\n  if (options.credentials === 'include') {\n    xhr.withCredentials = true;\n  }\n  xhr.addEventListener('readystatechange', onStateChange);\n  xhr.addEventListener('progress', onProgressEvent);\n  xhr.addEventListener('loadend', onLoadEvent);\n  xhr.addEventListener('error', onError);\n  xhr.send(options.body);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/impl/mozXhr.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XHR = undefined;\nexports.default = xhrRequest;\n\nvar _browserHeaders = require('browser-headers');\n\nvar XHR = exports.XHR = 'xhr';\n\nfunction xhrRequest(options) {\n  var textEncoder = new TextEncoder();\n  var xhr = new XMLHttpRequest();\n  var index = 0;\n\n  function onProgressEvent() {\n    var rawText = xhr.responseText.substr(index);\n    index = xhr.responseText.length;\n    options.onRawChunk(textEncoder.encode(rawText, { stream: true }));\n  }\n\n  function onLoadEvent() {\n    // Force the textEncoder to flush.\n    options.onRawChunk(textEncoder.encode(\"\", { stream: false }));\n    options.onRawComplete({\n      statusCode: xhr.status,\n      transport: XHR,\n      raw: xhr\n    });\n  }\n\n  function onStateChange() {\n    if (this.readyState == this.HEADERS_RECEIVED) {\n      options.onRawHeaders(new _browserHeaders.BrowserHeaders(this.getAllResponseHeaders()), this.status);\n    }\n  }\n\n  function onError(err) {\n    options.onRawComplete({\n      statusCode: 0,\n      transport: XHR,\n      raw: err\n    });\n  }\n\n  xhr.open(options.method, options.url);\n  xhr.responseType = 'text';\n  options.headers.forEach(function (key, values) {\n    xhr.setRequestHeader(key, values.join(\", \"));\n  });\n  if (options.credentials === 'include') {\n    xhr.withCredentials = true;\n  }\n  xhr.addEventListener('readystatechange', onStateChange);\n  xhr.addEventListener('progress', onProgressEvent);\n  xhr.addEventListener('loadend', onLoadEvent);\n  xhr.addEventListener('error', onError);\n  xhr.send(options.body);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/impl/xhr.js\n// module id = 6\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.isObject = isObject;\nexports.noop = noop;\nfunction isObject(value) {\n  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n}\n\nfunction noop() {\n  /* No operation */\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util.js\n// module id = 7\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar BrowserHeaders = (function () {\n    function BrowserHeaders(init, options) {\n        if (init === void 0) { init = \"\"; }\n        if (options === void 0) { options = { splitValues: false }; }\n        var _this = this;\n        this.keyValueMap = {};\n        if (init) {\n            if (typeof Headers !== \"undefined\" && init instanceof Headers) {\n                var keys = util_1.getHeaderKeys(init);\n                keys.forEach(function (key) {\n                    var values = util_1.getHeaderValues(init, key);\n                    values.forEach(function (value) {\n                        if (options.splitValues) {\n                            _this.append(key, util_1.splitHeaderValue(value));\n                        }\n                        else {\n                            _this.append(key, value);\n                        }\n                    });\n                });\n            }\n            else if (init instanceof BrowserHeaders) {\n                init.forEach(function (key, values) {\n                    _this.append(key, values);\n                });\n            }\n            else if (typeof Map !== \"undefined\" && init instanceof Map) {\n                var asMap = init;\n                asMap.forEach(function (value, key) {\n                    _this.append(key, value);\n                });\n            }\n            else if (typeof init === \"string\") {\n                this.appendFromString(init);\n            }\n            else if (typeof init === \"object\") {\n                Object.getOwnPropertyNames(init).forEach(function (key) {\n                    var asObject = init;\n                    var values = asObject[key];\n                    if (Array.isArray(values)) {\n                        values.forEach(function (value) {\n                            _this.append(key, value);\n                        });\n                    }\n                    else {\n                        _this.append(key, values);\n                    }\n                });\n            }\n        }\n    }\n    BrowserHeaders.prototype.appendFromString = function (str) {\n        var pairs = str.split(\"\\r\\n\");\n        for (var i = 0; i < pairs.length; i++) {\n            var p = pairs[i];\n            var index = p.indexOf(\": \");\n            if (index > 0) {\n                var key = p.substring(0, index);\n                var value = p.substring(index + 2);\n                this.append(key, value);\n            }\n        }\n    };\n    BrowserHeaders.prototype.delete = function (key, value) {\n        var normalizedKey = util_1.normalizeName(key);\n        if (value === undefined) {\n            delete this.keyValueMap[normalizedKey];\n        }\n        else {\n            var existing = this.keyValueMap[normalizedKey];\n            if (existing) {\n                var index = existing.indexOf(value);\n                if (index >= 0) {\n                    existing.splice(index, 1);\n                }\n                if (existing.length === 0) {\n                    delete this.keyValueMap[normalizedKey];\n                }\n            }\n        }\n    };\n    BrowserHeaders.prototype.append = function (key, value) {\n        var _this = this;\n        var normalizedKey = util_1.normalizeName(key);\n        if (!Array.isArray(this.keyValueMap[normalizedKey])) {\n            this.keyValueMap[normalizedKey] = [];\n        }\n        if (Array.isArray(value)) {\n            value.forEach(function (arrayValue) {\n                _this.keyValueMap[normalizedKey].push(util_1.normalizeValue(arrayValue));\n            });\n        }\n        else {\n            this.keyValueMap[normalizedKey].push(util_1.normalizeValue(value));\n        }\n    };\n    BrowserHeaders.prototype.set = function (key, value) {\n        var normalizedKey = util_1.normalizeName(key);\n        if (Array.isArray(value)) {\n            var normalized_1 = [];\n            value.forEach(function (arrayValue) {\n                normalized_1.push(util_1.normalizeValue(arrayValue));\n            });\n            this.keyValueMap[normalizedKey] = normalized_1;\n        }\n        else {\n            this.keyValueMap[normalizedKey] = [util_1.normalizeValue(value)];\n        }\n    };\n    BrowserHeaders.prototype.has = function (key, value) {\n        var keyArray = this.keyValueMap[util_1.normalizeName(key)];\n        var keyExists = Array.isArray(keyArray);\n        if (!keyExists) {\n            return false;\n        }\n        if (value !== undefined) {\n            var normalizedValue = util_1.normalizeValue(value);\n            return keyArray.indexOf(normalizedValue) >= 0;\n        }\n        else {\n            return true;\n        }\n    };\n    BrowserHeaders.prototype.get = function (key) {\n        var values = this.keyValueMap[util_1.normalizeName(key)];\n        if (values !== undefined) {\n            return values.concat();\n        }\n        return [];\n    };\n    BrowserHeaders.prototype.forEach = function (callback) {\n        var _this = this;\n        Object.getOwnPropertyNames(this.keyValueMap)\n            .forEach(function (key) {\n            callback(key, _this.keyValueMap[key]);\n        }, this);\n    };\n    return BrowserHeaders;\n}());\nexports.default = BrowserHeaders;\n//# sourceMappingURL=BrowserHeaders.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browser-headers/lib/BrowserHeaders.js\n// module id = 8\n// module chunks = 0","// This function is written in JS (ES5) to avoid an issue with TypeScript targeting ES5, but requiring Symbol.iterator\nfunction iterateHeaders(headers, callback) {\n  var iterator = headers[Symbol.iterator]();\n  var entry = iterator.next();\n  while(!entry.done) {\n    callback(entry.value[0]);\n    entry = iterator.next();\n  }\n}\n\nfunction iterateHeadersKeys(headers, callback) {\n  var iterator = headers.keys();\n  var entry = iterator.next();\n  while(!entry.done) {\n    callback(entry.value);\n    entry = iterator.next();\n  }\n}\n\nmodule.exports = {\n  iterateHeaders: iterateHeaders,\n  iterateHeadersKeys: iterateHeadersKeys\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browser-headers/lib/js/iterateHeaders.js\n// module id = 9\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iterateHeaders_1 = require(\"./js/iterateHeaders\");\nfunction normalizeName(name) {\n    if (typeof name !== \"string\") {\n        name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n        throw new TypeError(\"Invalid character in header field name\");\n    }\n    return name.toLowerCase();\n}\nexports.normalizeName = normalizeName;\nfunction normalizeValue(value) {\n    if (typeof value !== \"string\") {\n        value = String(value);\n    }\n    return value;\n}\nexports.normalizeValue = normalizeValue;\nfunction getHeaderValues(headers, key) {\n    if (headers instanceof Headers && headers.getAll) {\n        return headers.getAll(key);\n    }\n    var getValue = headers.get(key);\n    if (getValue && typeof getValue === \"string\") {\n        return [getValue];\n    }\n    return getValue;\n}\nexports.getHeaderValues = getHeaderValues;\nfunction getHeaderKeys(headers) {\n    var asMap = {};\n    var keys = [];\n    if (headers.keys) {\n        iterateHeaders_1.iterateHeadersKeys(headers, function (key) {\n            if (!asMap[key]) {\n                asMap[key] = true;\n                keys.push(key);\n            }\n        });\n    }\n    else if (headers.forEach) {\n        headers.forEach(function (_, key) {\n            if (!asMap[key]) {\n                asMap[key] = true;\n                keys.push(key);\n            }\n        });\n    }\n    else {\n        iterateHeaders_1.iterateHeaders(headers, function (entry) {\n            var key = entry[0];\n            if (!asMap[key]) {\n                asMap[key] = true;\n                keys.push(key);\n            }\n        });\n    }\n    return keys;\n}\nexports.getHeaderKeys = getHeaderKeys;\nfunction splitHeaderValue(str) {\n    var values = [];\n    var commaSpaceValues = str.split(\", \");\n    commaSpaceValues.forEach(function (commaSpaceValue) {\n        commaSpaceValue.split(\",\").forEach(function (commaValue) {\n            values.push(commaValue);\n        });\n    });\n    return values;\n}\nexports.splitHeaderValue = splitHeaderValue;\n//# sourceMappingURL=util.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browser-headers/lib/util.js\n// module id = 10\n// module chunks = 0","module.exports = require(\"./index\").default;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/entry.js\n// module id = 11\n// module chunks = 0"],"sourceRoot":""}